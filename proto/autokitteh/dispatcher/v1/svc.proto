syntax = "proto3";

package autokitteh.dispatcher.v1;

import "autokitteh/events/v1/event.proto";
import "buf/validate/validate.proto";

message DispatchRequest {
  option (buf.validate.message).cel = {
    id: "dispatcher.event_id_must_be_empty"
    message: "event_id must not be specified"
    expression: "has(this.event) && this.event.event_id == ''"
  };

  events.v1.Event event = 1;

  string deployment_id = 2;
  string project = 3; // either project id or name.
  bool wait = 4; // if true, the call will block until the dispatch is done.
}

message DispatchResponse {
  string event_id = 1 [(buf.validate.field).string.min_len = 1];
  repeated string session_ids = 2 [(buf.validate.field).repeated.items.string.min_len = 1]; // only if wait
}

message RedispatchRequest {
  string event_id = 1 [(buf.validate.field).string.min_len = 1];
  string deployment_id = 3;
  bool wait = 4; // if true, the call will block until the dispatch is done.
}

message RedispatchResponse {
  string event_id = 1 [(buf.validate.field).string.min_len = 1];
  repeated string session_ids = 2 [(buf.validate.field).repeated.items.string.min_len = 1]; // only if wait
}

service DispatcherService {
  rpc Dispatch(DispatchRequest) returns (DispatchResponse);

  // Does not creates the event, just resends an existing one.
  // This method also duplicates the event, and generates a new
  // event ID for it. The new event ID is returned in the response.
  rpc Redispatch(RedispatchRequest) returns (RedispatchResponse);
}
